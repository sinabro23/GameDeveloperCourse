F는 Struct


{
	FMath::Clamp(Value, -1.f, 1.f)
	// min 과 max 사이의 값으로 한정 지어줌 ex) 10으로 값이들어와도 1로 
}

{ [이동 함수] - 기존프로젝트에서 가져왔음
	const FRotator Rotation{ Controller->GetControlRotation() }; // 컨트롤러의 로테이션 기준으로 앞으로가야함
	const FRotator YawRotation{ 0, Rotation.Yaw, 0 }; //컨트롤러의 Yaw값만 중요하니깐
	const FVector Direction{ FRotationMatrix{YawRotation}.GetUnitAxis(EAxis::X) }; // X가 언리얼기준 정면
	AddMovementInput(Direction, Value);
}

{
	SphereComponent->InitSphereRadius(40.f); // 반지름
	Sphere->SetCollisionProfileName(TEXT("Pawn"));  // 콜리전 프리셋의 오브젝트타입이 Pawn으로 됨
}

{
	static ConstructorHelpers::FObjectFinder<UStaticMesh> SM_Collider(TEXT("StaticMesh'/Game/StarterContent/Shapes/Shape_Sphere.Shape_Sphere'"));
	if (SM_Collider.Succeeded())
	{
		Mesh->SetStaticMesh(SM_Collider.Object);
		Mesh->SetRelativeLocation(FVector(0.f, 0.f, -40.f)); // 스피어컴포넌트와 바닥이 맞지않았음
		Mesh->SetWorldScale3D(FVector(0.8f, 0.8f, 0.8f)); // 크기 3D벡터단위로 비율을 줄일때
	}
}

{
	void ACollider::MoveForward(float Value)
	{
		FVector Forward = GetActorForwardVector();
		AddMovementInput(Forward * Value); // 인자로 들어가는 값은 한프레임에 얼마나 움직일지
}
}

{
	캐릭터는 메쉬, 캡슐컴포넌트, 무브먼트컴포넌트를 들고있음
	캡슐이 기본 루트컴포넌트임
}

{
	CameraBoom->bUsePawnControlRotation = true; 컨트롤러로 돌릴때 카메라붐도 같이 돈다.
}


void AMain::MoveForward(float Value)
{
	if (Controller && 0 != Value)
	{
		// 정면기준으로 앞으로가야하고
		const FRotator ControllerRotator = Controller->GetControlRotation();
		const FRotator RotatorYaw = FRotator(0.f, ControllerRotator.Yaw, 0.f);
		const FVector Direction = FRotationMatrix(RotatorYaw).GetUnitAxis(EAxis::X);

		AddMovementInput(Direction, Value);
	}
}

void AMain::TurnAtRate(float Rate) // 키보드버전 턴
{
	AddControllerYawInput(Rate * BaseTurnRate * GetWorld()->GetDeltaSeconds());
}

{ // 마우스 돌리기
	PlayerInputComponent->BindAxis(TEXT("Turn"), this, &APawn::AddControllerYawInput);
	PlayerInputComponent->BindAxis(TEXT("Lookup"), this, &AMain::AddControllerPitchInput);
}
	
{
	PlayerInputComponent->BindAction(TEXT("Jump"), EInputEvent::IE_Pressed, this, &AMain::Jump);
	PlayerInputComponent->BindAction(TEXT("Jump"), EInputEvent::IE_Released, this, &AMain::StopJumping);
}

{
	GetCapsuleComponent()->SetCapsuleSize(43.f, 104.f);
}

{
	bUseControllerRotationPitch = false;
	bUseControllerRotationYaw = false;
	bUseControllerRotationRoll = false;
}

{
	GetCharacterMovement()->bOrientRotationToMovement = true;
	GetCharacterMovement()->RotationRate = FRotator(0.0f, 540.f, 0.f);  // 도는속도
	GetCharacterMovement()->JumpZVelocity = 650.f; // 점프 속도 
	GetCharacterMovement()->AirControl = 0.2f; // 공중에서 움직일수 있는 정도
}

{
	블렌드스페이스 : 애니메이션 어떤 기준에따라 천천히 섞는것 1D는 축이하나
}

{
	애님인스턴스
	float MovementSpeed, bool bIsInAir, Pawn* Pawn

	virtual void NativeInitializeAnimation() override;
	
	UFUNCTION(BlueprintCallable, Category = AnimationProperties)
	void UpdateAnimationProperties(); // 스스로 만든 함수 블루프린트에서 Event Bluprint Update Animation에 붙이려고

	생성자에서 하면 안됨.

	if(nullptr == Pawn)
	{
		Pawn = TryGetPawnOwner();
	}

	void UpdateAnimationProperties()
	{
		FVector Speed = Pawn->GetVelocity();
		Speed.Z = 0.f;
		MovementSpeed = Speed.Size();

		bIsInAir = Pawn->GetMovementComponent()->IsFalling();
	}
}

{
	애님인스턴스 cpp로 만든것 바로 상속받아서 블루프린트 만들지 말고
	애니메이션 블루프린트로 만들어서 애님인스턴스 상속클릭
}

{
	점프스타트 -> inAir // 점프스탑 -> Idle
	조건 : Time remaining ratio < 비율( 점프스타트 애니메이션에서 직접보고 20%정도 지나면)
}

{
	UBoxComponent / USphereComponent => 충돌체용으로
}

{
	// 오버랩이 발생하면 바인딩한 함수 호출 // 생성자보다는 BeginPlay에 
	TriggerBox->OnComponentBeginOverlap.AddDynamic(this, &AFloorSwitch::OnOverlapBegin)
	TriggerBox->OnComponentEndOverlap.AddDynamic(this, &AFloorSwitch::OnOverlapEnd)

	UFUNCTION()
	void OnOverlapBegin(UPrimitiveComponent* OverlappedComponent, 
						AActor* OtherActor,
						UPrimitiveComponent* OtherComp,
						int32 OtherBodyIndex,
						bool bFromSweep,
						const FHitResult & SweepResult);
	UFUNCTION()
	void OnOverlapEnd(UPrimitiveComponent* OverlappedComponent, 
					  AActor* OtherActor,
					  UPrimitiveComponent* OtherComp,
					  int32 OtherBodyIndex);

	TriggerBox->SetCollisionEnabled(EcolisionEnabled::QueryOnly); // 쿼리만 가능하게 
	TriggerBox->SetCollisionObjectType(EcollisionChannel::ECC_WorldStatic);
	TriggerBox->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore); // 일단 모든채널 이그노어
	TriggerBox->SetCollisionResponseToChannel(ECollisionChannel::ECC_Pawn, ECollsionResponse::ECR_Overlap); // Pawn에게는 반응하게
	TriggerBox->SetBoxExtent(FVector());

	이벤트체크 같은것은 캡슐끼리 콜리전체크함 메쉬가 아니라(메쉬 계산은 너무비쌈)
}

{
	UFUNCTION(BlueprintImplementableEvent, Category = "Floor Switch") 
	void RaiseDoor(); 
	UFUNCTION(BlueprintImplementableEvent, Category = "Floor Switch") 
	void LowerDoor(); 
	// BlueprintImplementableEvent CPP에서 구현 안해도 블루프린트에서 구현 가능
}


{
	이벤트그래프에서 타임라인 사용하면 천천히 밸류 올릴수 있음 43강
}

{
	FTimerHandle SwitchHandle;
	float SwitchCloseTime = 2.f;

	onoverlapEnd()
	{
		GetWorldTimerManager().SetTimer(SwitchHandle, this, &AFloorSwitch::CloseDoor, SwitchTime)
	}
}